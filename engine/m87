#!/bin/env python3

"""M87

Usage:
    m87
    m87 (-h | --help | --version)
"""

import os
import sys
import subprocess
from docopt import docopt
import chess
import bestmove
import perft

NAME = "M87"
VERSION = "{} 0.2.0".format(NAME)
AUTHOR = "nrobinaubertin"
CURRENT_BOARD = chess.Board()


def uci_parser(line):
    global CURRENT_BOARD
    tokens = line.strip().split()

    if not tokens:
        return []

    if len(tokens) == 1 and tokens[0] == "uci":
        return [
            "{} by {}".format(VERSION, AUTHOR),
            "id name {}".format(NAME),
            "id author {}".format(AUTHOR),
            # fake some options
            "option name Hash type spin default 16 min 1 max 33554432",
            "option name Move Overhead type spin default 10 min 0 max 5000",
            "option name Threads type spin default 1 min 1 max 512",
            "uciok",
        ]

    if tokens[0] == "ucinewgame":
        return []

    if tokens[0] == "isready":
        return [
            "readyok",
        ]

    if len(tokens) > 1 and tokens[0] == "position":
        if tokens[1] == "startpos":
            fen = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1"
            next_token = 2
        else:
            fen = "{0} {1} {2} {3} {4} {5}".format(
                tokens[1],
                tokens[2],
                tokens[3],
                tokens[4],
                tokens[5] if len(tokens) > 5 else 0,
                tokens[6] if len(tokens) > 6 else 0,
            )
            next_token = 7
        board = chess.Board(fen)
        if len(tokens) > next_token and tokens[next_token] == "moves":
            for move in tokens[next_token + 1 :]:
                board.push(chess.Move.from_uci(move))
        CURRENT_BOARD = board

    if len(tokens) > 1 and tokens[0] == "perft":
        depth = int(tokens[1])
        if depth == 0:
            nodes = 1
        else:
            nodes = perft.perft(CURRENT_BOARD.fen(), depth)
        return [f"nodes {nodes}"]

    if len(tokens) > 1 and tokens[0] == "go":

        depth = None

        if len(tokens) > 8:
            if tokens[1] == "wtime":
                wtime = int(tokens[2])
            if tokens[3] == "btime":
                btime = int(tokens[4])
            if tokens[5] == "winc":
                winc = int(tokens[6])
            if tokens[7] == "binc":
                binc = int(tokens[8])

        if tokens[1] == "movetime":
            wtime = int(tokens[2])
            btime = int(tokens[2])
            winc = 0
            binc = 0

        if tokens[1] == "depth":
            depth = int(tokens[2])

        if depth is None:
            my_time = wtime + winc
            if CURRENT_BOARD.turn == chess.BLACK:
                my_time = btime + binc

            depth = 1
            if my_time > 60 * 1000:
                depth = 2
            if my_time > 120 * 1000:
                depth = 3
        best_move = bestmove.bestMove(CURRENT_BOARD.fen(), depth)
        return ["bestmove {}".format(best_move)]
    return []


if __name__ == "__main__":
    args = docopt(str(__doc__), version=VERSION)
    while True:
        line = input()
        output = uci_parser(line)
        for line in output:
            print(line)
